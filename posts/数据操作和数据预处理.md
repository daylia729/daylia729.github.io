---
title: 数据操作
description: 数据操作和数据预处理
date: 2025-05-30
tags:
  - 深度学习
---
#### 数据操作
##### N维数组样例
* N维数组是机器学习和神经网络的主要数据结构
0-d（标量） 一个类别
1-d（向量） 一个特征向量 
2-d（矩阵） 一个样本-特征矩阵
3-d     &nbsp;&nbsp;   RGB图片（宽×高×通道）
4-d     &nbsp;&nbsp;   一个RGB图片批量（批量大小×宽×高×通道）
5-d &nbsp;&nbsp; 一个视频批量（批量大小×时间×宽×高×通道）
##### 创建数组
创建数组需要
* 形状：例如3×4矩阵
* 每个元素的数据类型：例如32位浮点数
* 每个元素的值：例如全是0，或者随机数（正态分布、均匀分布 ...）
##### 访问元素
一个元素：[1,2]
一行：[1,:]
一列：[:,1]
子区域：[1:3,1:]（拿到第二行和第三行，因为是开区间，后面是拿到第二列和后面所有列）
子区域：[::3,::2]（行是每3行一跳，把第0行和第三行拿出来；列是每两列一跳，把第0列和第二列拿出来）
#### 数据操作实现
* 首先我们应该导入torch，注意不是pytorch
`import torch`
* 张量表示一个数值组成的数组，这个数组可能有多个维度
`x = torch.arange(12)`
 torch.arange是Pytorch中用于创建等差张量的函数，输出tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
* 我们可以通过张量的shape属性来访问张量的形状和张量中的元素的总数
`x.shape` 输出tensor.Size([12])
`x.numel()`number of element length 输出12 是一个标量
* 要想改变一个张量的形状而不改变元素数量和元素值，我们可以调用`reshape`函数
`x = x.reshape(3,4)`
输出为
`tensor([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
`
* 使用全0、全1、其他常量或者从特定分布中随机采样的数字
`torch.zeros((2,3,4))` 
输出为
```
tensor([[[0., 0., 0., 0.],
         [0., 0., 0., 0.],
         [0., 0., 0., 0.]],

        [[0., 0., 0., 0.],
         [0., 0., 0., 0.],
         [0., 0., 0., 0.]]])
```
这是2个3行4列的二维数组组成的三维数组
`torch.ones((2, 3, 4))`
输出为
```
tensor([[[1., 1., 1., 1.],
         [1., 1., 1., 1.],
         [1., 1., 1., 1.]],

        [[1., 1., 1., 1.],
         [1., 1., 1., 1.],
         [1., 1., 1., 1.]]])
```
* 通过提供包含数值的Python列表（或嵌套列表）来为所需张量中的每个元素赋予确定值
`torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])`
输出为
```
tensor([[2, 1, 4, 3],
        [1, 2, 3, 4],
        [4, 3, 2, 1]])
```
* 选择张量中的元素
`X[-1], X[1:3]`
输出为
```
(tensor([ 8,  9, 10, 11]),
 tensor([[ 4,  5,  6,  7],
         [ 8,  9, 10, 11]]))
```
[-1]选择最后一行并[1:3]选择第二行和第三行（Python索引从0开始，切片范围为左闭右开，即包含起始索引，不包含结束索引）
还可以指定索引来写矩阵的元素
* 常见的标准算术运算符（`+`、`-`、`*`、`/`和`**`）都可以被升级为按元素计算
（`**`运算符是求幂运算）
```
x = torch.tensor([1.0, 2, 4, 8])
y = torch.tensor([2, 2, 2, 2])
x + y, x - y, x * y, x / y, x ** y
```
```
(tensor([ 3.,  4.,  6., 10.]),
 tensor([-1.,  0.,  2.,  6.]),
 tensor([ 2.,  4.,  8., 16.]),
 tensor([0.5000, 1.0000, 2.0000, 4.0000]),
 tensor([ 1.,  4., 16., 64.]))
 ```
 还有指数运算
 `torch.exp(x)`（e的x次方的）
* 我们也可以把多个张量连结在一起
```
X = torch.arange(12, dtype=torch.float32).reshape((3,4))
Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
torch.cat((X, Y), dim=0), torch.cat((X, Y), dim=1)
```
dim=0 按行连结在一起；dim=1 按列连结在一起
如果是一个三维张量（通道数×高×宽）
 * 在第0维（深度方向）连结 dim=0
 * 在第1维（高度方向）连结 dim=1
 * 在第2维（宽度方向）连结 dim=2
```
(tensor([[ 0.,  1.,  2.,  3.],
         [ 4.,  5.,  6.,  7.],
         [ 8.,  9., 10., 11.],
         [ 2.,  1.,  4.,  3.],
         [ 1.,  2.,  3.,  4.],
         [ 4.,  3.,  2.,  1.]]),
 tensor([[ 0.,  1.,  2.,  3.,  2.,  1.,  4.,  3.],
         [ 4.,  5.,  6.,  7.,  1.,  2.,  3.,  4.],
         [ 8.,  9., 10., 11.,  4.,  3.,  2.,  1.]]))
```
还可以通过逻辑运算符来构建二元张量
`X == Y`  按元素进行判断
```
tensor([[False,  True, False,  True],
        [False, False, False, False],
        [False, False, False, False]])
```
* 对张量中所有的元素进行求和会产生一个只有一个元素的张量
`X.sum()`
`tensor(66.)`
* 注意即使形状不同，我们仍然可以通过调用广播机制（broadcasting mechanism） 来执行按元素操作
```
a = torch.arange(3).reshape((3, 1))
b = torch.arange(2).reshape((1, 2))
a, b
(tensor([[0],
         [1],
         [2]]),
 tensor([[0, 1]]))
 ```
 这里a是一个三行一列的二维数组，b是一个一行两列的二维数组，他们两个相加的时候，a和b都会变成一个3×2的矩阵
 ```
 a + b
 tensor([[0, 1],
        [1, 2],
        [2, 3]])
```
* 内存
运行一些操作可能会为新结果分配内存
```
before = id(Y)
Y = Y + X
id(Y) == before
False
```
执行原地操作
```
Z = torch.zeros_like(Y)  #Z和Y的形状和数据类型是一样的，但是是全0
print('id(Z):', id(Z))
Z[:] = X + Y            #Z里面所有的元素等于X+Y 对Z中的元素进行一次改写
print('id(Z):', id(Z))
id(Z): 2658763724096
id(Z): 2658763724096
```
如果在后续计算中没有重复使用X，我们也可以使用`X[:] = X + Y`或者`X += Y `来减少操作的内存开销
```
before = id(X)
X += Y
id(X) == before
Ture
```
在Pytorch中，x = x + y 会分配新内存，x += y 不会分配新的内存（原地操作）
* 转换为NumPy张量
```
A = X.numpy()
B = torch.from_numpy(A)
type(A), type(B)
(numpy.ndarray, torch.Tensor)
```
将大小为1的张量转换为Python标量
```
a = torch.tensor([3.5])
a, a.item(), float(a), int(a)
(tensor([3.5000]), 3.5, 3.5, 3)
```




